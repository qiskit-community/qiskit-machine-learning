<!doctype html>
<html class="no-js" lang="es-UN">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Índice" href="../genindex.html" /><link rel="search" title="Búsqueda" href="../search.html" /><link rel="next" title="Machine Learning con Kernel Cuántico" href="03_quantum_kernel.html" /><link rel="prev" title="Redes Neuronales de Clasificación y Regresión" href="02_neural_network_classifier_and_regressor.html" />

    <!-- Generated with Sphinx 7.1.2 and Furo 2023.08.19 -->
        <title>Entrenamiento de un Modelo Cuántico en un Conjunto de Datos Real - Qiskit Machine Learning 0.7.1</title>
      <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fd506691" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/qiskit-sphinx-theme.css?v=fe84956c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/qiskit-ecosystem.css?v=745c5aa7" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #ffffff;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=IBM+Plex+Sans:ital,wght@0,400;0,600;1,400;1,600&display=swap" rel="stylesheet">
<script src="../_static/js/web-components/top-nav-bar.js"></script>
<script>
  (function () {
    window._analytics = {
      segment_key: 'ffdYLviQze3kzomaINXNk6NwpY9LlXcw',
      coremetrics: false,
      optimizely: false,
      googleAddServices: false,
      fullStory: false,
      autoPageEventSpa: false,
      autoFormEvents: false,
      autoPageView: false
    }

    window.digitalData = {
      page: {
        pageInfo: {
          productTitle: 'IBM Q Experience',
          analytics: {
            category: 'Qiskit.org'
          }
        }
      }
    }
  }());
</script>
<script src="https://cloud.ibm.com/analytics/build/bluemix-analytics.min.js"></script>
<script>
  (function () {
    'use strict'

    if (!window.bluemixAnalytics || !window.digitalData) { return }

    const category = window.digitalData.page.pageInfo.analytics.category
    const productTitle = window.digitalData.page.pageInfo.productTitle
    const routeName = 'documentation'

    window.bluemixAnalytics.pageEvent(category, routeName, {
      navigationType: 'pushState',
      productTitle: productTitle,
      title: document.title
    })

    window.trackCta = (action) => {
      if (!window.bluemixAnalytics || !window.digitalData) { return }

      const category = window.digitalData.page.pageInfo.analytics.category
      const productTitle = window.digitalData.page.pageInfo.productTitle

      window.bluemixAnalytics.trackEvent('CTA Clicked', {
        productTitle,
        category,
        CTA: action
      })
    }

  }());
</script></head>
  <body>
    
    <script>document.body.dataset.theme = "light";</script>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg id="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
      <defs><style>.cls-1{fill:none;}</style></defs>
      <path d="M28,4H4A2,2,0,0,0,2,6V26a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V6A2,2,0,0,0,28,4ZM4,6H20V26H4ZM28,26H22V6h6Z"/>
      <rect id="_Transparent_Rectangle_" data-name="&lt;Transparent Rectangle&gt;" class="cls-1" width="32" height="32"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg id="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
      <defs><style>.cls-1{fill:none;}</style></defs>
      <rect x="4" y="6" width="24" height="2"/>
      <rect x="4" y="24" width="24" height="2"/>
      <rect x="4" y="12" width="24" height="2"/>
      <rect x="4" y="18" width="24" height="2"/>
      <rect id="_Transparent_Rectangle_" data-name="&lt;Transparent Rectangle&gt;" class="cls-1" width="32" height="32"/>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg version="1.1" id="icon" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px"
         viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><polygon points="22,16 12,26 10.6,24.6 19.2,16 10.6,7.4 12,6 " stroke="currentColor"/>
      <rect id="_x3C_Transparent_Rectangle_x3E_" fill="none" width="32" height="32"/>
    </svg>
  </symbol>
  <symbol id="svg-new-tab" viewBox="0 0 32 32">
    <svg id="icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
      <defs>
        <style>
          .cls-1 {
            fill: none;
          }
        </style>
      </defs>
      <path fill="#6929C4" d="M26,28H6a2.0027,2.0027,0,0,1-2-2V6A2.0027,2.0027,0,0,1,6,4H16V6H6V26H26V16h2V26A2.0027,2.0027,0,0,1,26,28Z"/>
      <polygon fill="#6929C4" points="20 2 20 4 26.586 4 18 12.586 19.414 14 28 5.414 28 12 30 12 30 2 20 2"/>
      <rect id="_Transparent_Rectangle_" data-name="&lt;Transparent Rectangle&gt;" class="cls-1" width="32" height="32"/>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<div class="announcement">
  <aside class="announcement-content">
     This project's translations are no longer maintained. See the <a href=https://github.com/qiskit-community/qiskit-translations/tree/main#readme>announcement</a> 
  </aside>
</div>

<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">Qiskit Machine Learning 0.7.1</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-brand">
  <a href="https://www.qiskit.org/ecosystem">
    <div class="sidebar-logo-container">
      <img class="sidebar-logo" src="../_static/images/ecosystem-logo.svg" alt="Qiskit Ecosystem logo"/>
    </div>
  </a>
  
  <span class="sidebar-brand-text">Qiskit Machine Learning 0.7.1</span>
</div><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Búsqueda">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Descripción general</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Primeros Pasos</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../migration/index.html">Guía de Migración</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Guía de Migración</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../migration/01_migration_guide_0.5.html">Guía de Migración de Qiskit Machine Learning v0.5</a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">Tutoriales</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Tutoriales</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="01_neural_networks.html">Redes Neuronales Cuánticas</a></li>
<li class="toctree-l2"><a class="reference internal" href="02_neural_network_classifier_and_regressor.html">Redes Neuronales de Clasificación y Regresión</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Entrenamiento de un Modelo Cuántico en un Conjunto de Datos Real</a></li>
<li class="toctree-l2"><a class="reference internal" href="03_quantum_kernel.html">Machine Learning con Kernel Cuántico</a></li>
<li class="toctree-l2"><a class="reference internal" href="04_torch_qgan.html">Implementación de PyTorch qGAN</a></li>
<li class="toctree-l2"><a class="reference internal" href="05_torch_connector.html">Conector Torch y QNNs Híbridas</a></li>
<li class="toctree-l2"><a class="reference internal" href="07_pegasos_qsvc.html">Clasificador Cuántico de Vectores de Soporte tipo Pegasos</a></li>
<li class="toctree-l2"><a class="reference internal" href="08_quantum_kernel_trainer.html">Entrenamiento de Kernel Cuántico para Aplicaciones de Machine Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="09_saving_and_loading_models.html">Guardar, Cargar Modelos de Qiskit Machine Learning y Entrenamiento Continuo</a></li>
<li class="toctree-l2"><a class="reference internal" href="10_effective_dimension.html">Dimensión Efectiva de las Redes Neuronales de Qiskit</a></li>
<li class="toctree-l2"><a class="reference internal" href="11_quantum_convolutional_neural_networks.html">La Red Neuronal Convolucional Cuántica</a></li>
<li class="toctree-l2"><a class="reference internal" href="12_quantum_autoencoder.html">El Autocodificador Cuántico</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../apidocs/qiskit_machine_learning.html">Referencia de la API</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Referencia de la API</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../stubs/qiskit_machine_learning.QiskitMachineLearningError.html">QiskitMachineLearningError</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../apidocs/qiskit_machine_learning.algorithms.html">Quantum machine learning algorithms (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_machine_learning.algorithms</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of Quantum machine learning algorithms (qiskit_machine_learning.algorithms)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.algorithms.TrainableModel.html">TrainableModel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.algorithms.ObjectiveFunction.html">ObjectiveFunction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.algorithms.SerializableModelMixin.html">SerializableModelMixin</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.algorithms.BinaryObjectiveFunction.html">BinaryObjectiveFunction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.algorithms.MultiClassObjectiveFunction.html">MultiClassObjectiveFunction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.algorithms.OneHotObjectiveFunction.html">OneHotObjectiveFunction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.algorithms.PegasosQSVC.html">PegasosQSVC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.algorithms.QSVC.html">QSVC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.algorithms.NeuralNetworkClassifier.html">NeuralNetworkClassifier</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.algorithms.VQC.html">VQC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.algorithms.QSVR.html">QSVR</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.algorithms.NeuralNetworkRegressor.html">NeuralNetworkRegressor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.algorithms.VQR.html">VQR</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../apidocs/qiskit_machine_learning.circuit.library.html">Circuit library for machine learning applications (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_machine_learning.circuit.library</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of Circuit library for machine learning applications (qiskit_machine_learning.circuit.library)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.circuit.library.RawFeatureVector.html">RawFeatureVector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.circuit.library.QNNCircuit.html">QNNCircuit</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../apidocs/qiskit_machine_learning.connectors.html">Connectors (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_machine_learning.connectors</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of Connectors (qiskit_machine_learning.connectors)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.connectors.TorchConnector.html">TorchConnector</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../apidocs/qiskit_machine_learning.datasets.html">Datasets (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_machine_learning.datasets</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of Datasets (qiskit_machine_learning.datasets)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.datasets.ad_hoc_data.html">ad_hoc_data</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../apidocs/qiskit_machine_learning.kernels.html">Quantum kernels (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_machine_learning.kernels</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle navigation of Quantum kernels (qiskit_machine_learning.kernels)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.kernels.BaseKernel.html">BaseKernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.kernels.FidelityQuantumKernel.html">FidelityQuantumKernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.kernels.FidelityStatevectorKernel.html">FidelityStatevectorKernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.kernels.TrainableKernel.html">TrainableKernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.kernels.TrainableFidelityQuantumKernel.html">TrainableFidelityQuantumKernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.kernels.TrainableFidelityStatevectorKernel.html">TrainableFidelityStatevectorKernel</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apidocs/qiskit_machine_learning.kernels.algorithms.html">Quantum Kernel Algorithms</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle navigation of Quantum Kernel Algorithms</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../stubs/qiskit_machine_learning.kernels.algorithms.QuantumKernelTrainer.html">QuantumKernelTrainer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stubs/qiskit_machine_learning.kernels.algorithms.QuantumKernelTrainerResult.html">QuantumKernelTrainerResult</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../apidocs/qiskit_machine_learning.neural_networks.html">Quantum neural networks (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_machine_learning.neural_networks</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle navigation of Quantum neural networks (qiskit_machine_learning.neural_networks)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.neural_networks.NeuralNetwork.html">NeuralNetwork</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.neural_networks.EstimatorQNN.html">EstimatorQNN</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.neural_networks.SamplerQNN.html">SamplerQNN</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.neural_networks.EffectiveDimension.html">EffectiveDimension</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stubs/qiskit_machine_learning.neural_networks.LocalEffectiveDimension.html">LocalEffectiveDimension</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../apidocs/qiskit_machine_learning.utils.html">Utility functions and classes (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_machine_learning.utils</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle navigation of Utility functions and classes (qiskit_machine_learning.utils)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apidocs/qiskit_machine_learning.utils.loss_functions.html">Loss Functions (<code class="xref py py-mod docutils literal notranslate"><span class="pre">qiskit_machine_learning.utils.loss_functions</span></code>)</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><div class="visually-hidden">Toggle navigation of Loss Functions (qiskit_machine_learning.utils.loss_functions)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../stubs/qiskit_machine_learning.utils.loss_functions.Loss.html">Loss</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stubs/qiskit_machine_learning.utils.loss_functions.KernelLoss.html">KernelLoss</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stubs/qiskit_machine_learning.utils.loss_functions.L1Loss.html">L1Loss</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stubs/qiskit_machine_learning.utils.loss_functions.L2Loss.html">L2Loss</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stubs/qiskit_machine_learning.utils.loss_functions.CrossEntropyLoss.html">CrossEntropyLoss</a></li>
<li class="toctree-l4"><a class="reference internal" href="../stubs/qiskit_machine_learning.utils.loss_functions.SVCLoss.html">SVCLoss</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Notas de la Versión</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/qiskit-community/qiskit-machine-learning">GitHub</a></li>
</ul>

</div></div><div class="qiskit-translations-container" aria-label="languages">
  <input id="translations-checkbox" name="translations-checkbox" role="switch" type="checkbox">
  <div class="qiskit-translations-header-container"><label for="translations-checkbox">
      <p role="note">Spanish</p>
      <div class="qiskit-translations-toggle-container">
        <div class="visually-hidden">Toggle translations list</div>
        <i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i>
      </div>
    </label>
  </div>
  <div class="qiskit-translations-list-container">
    <ul>
      
        <li><a href="/qiskit-machine-learning/tutorials/02a_training_a_quantum_model_on_a_real_dataset.html">English</a></li>
      
        <li><a href="/qiskit-machine-learning/locale/bn_BN/tutorials/02a_training_a_quantum_model_on_a_real_dataset.html">Bengali</a></li>
      
        <li><a href="/qiskit-machine-learning/locale/fr_FR/tutorials/02a_training_a_quantum_model_on_a_real_dataset.html">French</a></li>
      
        <li><a href="/qiskit-machine-learning/locale/hi_IN/tutorials/02a_training_a_quantum_model_on_a_real_dataset.html">Hindi</a></li>
      
        <li><a href="/qiskit-machine-learning/locale/ja_JP/tutorials/02a_training_a_quantum_model_on_a_real_dataset.html">Japanese</a></li>
      
        <li><a href="/qiskit-machine-learning/locale/ko_KR/tutorials/02a_training_a_quantum_model_on_a_real_dataset.html">Korean</a></li>
      
        <li><a href="/qiskit-machine-learning/locale/ru_RU/tutorials/02a_training_a_quantum_model_on_a_real_dataset.html">Russian</a></li>
      
        <li><a href="/qiskit-machine-learning/locale/es_UN/tutorials/02a_training_a_quantum_model_on_a_real_dataset.html">Spanish</a></li>
      
        <li><a href="/qiskit-machine-learning/locale/ta_IN/tutorials/02a_training_a_quantum_model_on_a_real_dataset.html">Tamil</a></li>
      
        <li><a href="/qiskit-machine-learning/locale/tr_TR/tutorials/02a_training_a_quantum_model_on_a_real_dataset.html">Turkish</a></li>
      
    </ul>
  </div>
  <script>
    document.querySelectorAll('.version').forEach((element) => {
      element.addEventListener('click', (evt) => {
        const hash = window.location.hash;
        const complete_url = evt.target.href + hash;
        window.location = complete_url;
        evt.preventDefault();
      });
    });
  </script>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Esta página fue generada a partir de <a class="reference external" href="https://github.com/qiskit-community/qiskit-machine-learning/blob/stable/0.7/docs/tutorials/02a_training_a_quantum_model_on_a_real_dataset.ipynb">docs/tutorials/02a_training_a_quantum_model_on_a_real_dataset.ipynb</a>.</p>
</div>
<section id="Entrenamiento-de-un-Modelo-Cuántico-en-un-Conjunto-de-Datos-Real">
<h1>Entrenamiento de un Modelo Cuántico en un Conjunto de Datos Real<a class="headerlink" href="#Entrenamiento-de-un-Modelo-Cuántico-en-un-Conjunto-de-Datos-Real" title="Enlace permanente a este encabezado">#</a></h1>
<p>Este tutorial demostrará cómo entrenar un modelo de machine learning cuántico para abordar un problema de clasificación. Los tutoriales anteriores han presentado pequeños conjuntos de datos artificiales. Aquí aumentaremos la complejidad del problema al considerar un conjunto de datos clásico de la vida real. Decidimos elegir un problema muy conocido, aunque todavía relativamente pequeño: el conjunto de datos de la flor Iris. Este conjunto de datos incluso tiene su propia <a class="reference external" href="https://en.wikipedia.org/wiki/Iris_flower_data_set">página de Wikipedia</a>. Aunque el conjunto de datos de Iris es bien conocido por los científicos de datos, lo presentaremos brevemente para refrescarnos la memoria. A modo de comparación, primero entrenaremos una contraparte clásica del modelo cuántico.</p>
<p>Entonces, empecemos:</p>
<ul class="simple">
<li><p>Primero, cargaremos el conjunto de datos y exploraremos cómo se ve.</p></li>
<li><p>A continuación, entrenaremos un modelo clásico usando <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html">SVC</a> de <a class="reference external" href="https://scikit-learn.org/">scikit-learn</a> para ver qué tan bien se puede resolver el problema de clasificación usando métodos clásicos.</p></li>
<li><p>Después de eso, presentaremos el Clasificador Cuántico Variacional (Variational Quantum Classifier, VQC).</p></li>
<li><p>Para concluir, compararemos los resultados obtenidos con ambos modelos.</p></li>
</ul>
<section id="1.-Análisis-de-Datos-Exploratorios">
<h2>1. Análisis de Datos Exploratorios<a class="headerlink" href="#1.-Análisis-de-Datos-Exploratorios" title="Enlace permanente a este encabezado">#</a></h2>
<p>Primero, exploremos el conjunto de datos de Iris que usarás este tutorial y veamos qué contiene. Para nuestra comodidad, este <a class="reference external" href="https://scikit-learn.org/stable/datasets/toy_dataset.html#iris-dataset">conjunto de datos</a> está disponible en scikit-learn y se puede cargar fácilmente.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_iris</span>

<span class="n">iris_data</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>Si no se especifican parámetros en la función <code class="docutils literal notranslate"><span class="pre">load_iris</span></code>, scikit-learn devuelve un objeto similar a un diccionario. Imprimamos la descripción del conjunto de datos y veamos qué hay dentro.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">iris_data</span><span class="o">.</span><span class="n">DESCR</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
.. _iris_dataset:

Iris plants dataset
--------------------

**Data Set Characteristics:**

    :Number of Instances: 150 (50 in each of three classes)
    :Number of Attributes: 4 numeric, predictive attributes and the class
    :Attribute Information:
        - sepal length in cm
        - sepal width in cm
        - petal length in cm
        - petal width in cm
        - class:
                - Iris-Setosa
                - Iris-Versicolour
                - Iris-Virginica

    :Summary Statistics:

    ============== ==== ==== ======= ===== ====================
                    Min  Max   Mean    SD   Class Correlation
    ============== ==== ==== ======= ===== ====================
    sepal length:   4.3  7.9   5.84   0.83    0.7826
    sepal width:    2.0  4.4   3.05   0.43   -0.4194
    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)
    petal width:    0.1  2.5   1.20   0.76    0.9565  (high!)
    ============== ==== ==== ======= ===== ====================

    :Missing Attribute Values: None
    :Class Distribution: 33.3% for each of 3 classes.
    :Creator: R.A. Fisher
    :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)
    :Date: July, 1988

The famous Iris database, first used by Sir R.A. Fisher. The dataset is taken
from Fisher&#39;s paper. Note that it&#39;s the same as in R, but not as in the UCI
Machine Learning Repository, which has two wrong data points.

This is perhaps the best known database to be found in the
pattern recognition literature.  Fisher&#39;s paper is a classic in the field and
is referenced frequently to this day.  (See Duda &amp; Hart, for example.)  The
data set contains 3 classes of 50 instances each, where each class refers to a
type of iris plant.  One class is linearly separable from the other 2; the
latter are NOT linearly separable from each other.

.. topic:: References

   - Fisher, R.A. &#34;The use of multiple measurements in taxonomic problems&#34;
     Annual Eugenics, 7, Part II, 179-188 (1936); also in &#34;Contributions to
     Mathematical Statistics&#34; (John Wiley, NY, 1950).
   - Duda, R.O., &amp; Hart, P.E. (1973) Pattern Classification and Scene Analysis.
     (Q327.D83) John Wiley &amp; Sons.  ISBN 0-471-22361-1.  See page 218.
   - Dasarathy, B.V. (1980) &#34;Nosing Around the Neighborhood: A New System
     Structure and Classification Rule for Recognition in Partially Exposed
     Environments&#34;.  IEEE Transactions on Pattern Analysis and Machine
     Intelligence, Vol. PAMI-2, No. 1, 67-71.
   - Gates, G.W. (1972) &#34;The Reduced Nearest Neighbor Rule&#34;.  IEEE Transactions
     on Information Theory, May 1972, 431-433.
   - See also: 1988 MLC Proceedings, 54-64.  Cheeseman et al&#34;s AUTOCLASS II
     conceptual clustering system finds 3 classes in the data.
   - Many, many more ...
</pre></div></div>
</div>
<p>Hay algunas observaciones interesantes que podemos encontrar en esta descripción del conjunto de datos:</p>
<ul class="simple">
<li><p>Hay 150 muestras (instancias) en el conjunto de datos.</p></li>
<li><p>Hay cuatro características (atributos) en cada muestra.</p></li>
<li><p>Hay tres etiquetas (clases) en el conjunto de datos.</p></li>
<li><p>El conjunto de datos está perfectamente equilibrado, ya que hay el mismo número de muestras (50) en cada clase.</p></li>
<li><p>Podemos ver que las características no están normalizadas y sus rangos de valores son diferentes, por ejemplo, <span class="math notranslate nohighlight">\([4.3, 7.9]\)</span> y <span class="math notranslate nohighlight">\([0.1, 2.5]\)</span> para la longitud del sépalo y el ancho del pétalo, respectivamente. Por lo tanto, puede ser útil transformar las características a la misma escala.</p></li>
<li><p>Como se indica en la tabla anterior, la correlación de característica a clase en algunos casos es muy alta; esto puede llevarnos a pensar que nuestro modelo debería adaptarse bien al conjunto de datos.</p></li>
</ul>
<p>Solo examinamos la descripción del conjunto de datos, pero hay propiedades adicionales disponibles en el objeto <code class="docutils literal notranslate"><span class="pre">iris_data</span></code>. Ahora vamos a trabajar con características y etiquetas del conjunto de datos.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">features</span> <span class="o">=</span> <span class="n">iris_data</span><span class="o">.</span><span class="n">data</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">iris_data</span><span class="o">.</span><span class="n">target</span>
</pre></div>
</div>
</div>
<p>En primer lugar, normalizaremos las características. Es decir, aplicaremos una transformación simple para representar todas las características en la misma escala. En nuestro caso, comprimimos todas las funciones en el intervalo <span class="math notranslate nohighlight">\([0, 1]\)</span>. La normalización es una técnica común en el machine learning y, a menudo, conduce a una mejor estabilidad numérica y convergencia de un algoritmo.</p>
<p>Podemos usar <code class="docutils literal notranslate"><span class="pre">MinMaxScaler</span></code> de scikit-learn para realizar esto. Sin especificar parámetros, esto hace exactamente lo que se requiere: mapea los datos a <span class="math notranslate nohighlight">\([0, 1]\)</span>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span>

<span class="n">features</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Veamos cómo se ven nuestros datos. Graficamos las características por pares para ver si hay una correlación observable entre ellas.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">iris_data</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">iris_data</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">iris_data</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>

<span class="n">sns</span><span class="o">.</span><span class="n">pairplot</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s2">&quot;class&quot;</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="s2">&quot;tab10&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;seaborn.axisgrid.PairGrid at 0x1c92dbc4188&gt;
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorials_02a_training_a_quantum_model_on_a_real_dataset_9_1.png" src="../_images/tutorials_02a_training_a_quantum_model_on_a_real_dataset_9_1.png" />
</div>
</div>
<p>De las gráficas, vemos que la clase <code class="docutils literal notranslate"><span class="pre">0</span></code> es fácilmente separable de las otras dos clases, mientras que las clases <code class="docutils literal notranslate"><span class="pre">1</span></code> y <code class="docutils literal notranslate"><span class="pre">2</span></code> a veces están empalmadas, especialmente con respecto a la característica del «ancho del sépalo».</p>
<p>A continuación, veamos cómo el machine learning clásico maneja este conjunto de datos.</p>
</section>
<section id="2.-Entrenamiento-de-un-Modelo-Clásico-de-Machine-Learning">
<h2>2. Entrenamiento de un Modelo Clásico de Machine Learning<a class="headerlink" href="#2.-Entrenamiento-de-un-Modelo-Clásico-de-Machine-Learning" title="Enlace permanente a este encabezado">#</a></h2>
<p>Antes de entrenar un modelo, debemos dividir el conjunto de datos en dos partes: un conjunto de datos de entrenamiento y un conjunto de datos de prueba. Usaremos el primero para entrenar el modelo y el segundo para verificar qué tan bien funcionan nuestros modelos en datos no vistos.</p>
<p>Como de costumbre, le pediremos a scikit-learn que haga el trabajo aburrido por nosotros. También fijaremos la semilla para garantizar que los resultados sean reproducibles.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">qiskit_algorithms.utils</span> <span class="kn">import</span> <span class="n">algorithm_globals</span>

<span class="n">algorithm_globals</span><span class="o">.</span><span class="n">random_seed</span> <span class="o">=</span> <span class="mi">123</span>
<span class="n">train_features</span><span class="p">,</span> <span class="n">test_features</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">,</span> <span class="n">test_labels</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
    <span class="n">features</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">algorithm_globals</span><span class="o">.</span><span class="n">random_seed</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>Entrenamos un clasificador de vectores de soporte clásico de scikit-learn. En aras de la simplicidad, no modificamos ningún parámetro y confiamos en los valores predeterminados.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>

<span class="n">svc</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">()</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">svc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_features</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>  <span class="c1"># suppress printing the return value</span>
</pre></div>
</div>
</div>
<p>Ahora comprobamos qué tan bien funciona nuestro modelo clásico. Analizaremos las puntuaciones en el apartado de conclusiones.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_score_c4</span> <span class="o">=</span> <span class="n">svc</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">train_features</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>
<span class="n">test_score_c4</span> <span class="o">=</span> <span class="n">svc</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">test_features</span><span class="p">,</span> <span class="n">test_labels</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Classical SVC on the training dataset: </span><span class="si">{</span><span class="n">train_score_c4</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Classical SVC on the test dataset:     </span><span class="si">{</span><span class="n">test_score_c4</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Classical SVC on the training dataset: 0.99
Classical SVC on the test dataset:     0.97
</pre></div></div>
</div>
<p>Como puede verse en las puntuaciones, el algoritmo SVC clásico funciona muy bien. A continuación, es hora de analizar los modelos de machine learning cuántico.</p>
</section>
<section id="3.-Entrenamiento-de-un-Modelo-de-Machine-Learning-Cuántico">
<h2>3. Entrenamiento de un Modelo de Machine Learning Cuántico<a class="headerlink" href="#3.-Entrenamiento-de-un-Modelo-de-Machine-Learning-Cuántico" title="Enlace permanente a este encabezado">#</a></h2>
<p>Como ejemplo de un modelo cuántico, entrenaremos un clasificador cuántico variacional (variational quantum classifier, VQC). El VQC es el clasificador más simple disponible en Qiskit Machine Learning y es un buen punto de partida para los recién llegados al machine learning cuántico que tienen experiencia en el machine learning clásico.</p>
<p>Pero antes de entrenar un modelo, examinemos qué comprende la clase <code class="docutils literal notranslate"><span class="pre">VQC</span></code>. Dos de sus elementos centrales son el mapa de características y el ansatz. Ahora se explicará cuáles son.</p>
<p>Nuestros datos son clásicos, lo que significa que consisten en un conjunto de bits, no de qubits. Necesitamos una forma de codificar los datos como qubits. Este proceso es crucial si queremos obtener un modelo cuántico efectivo. Por lo general, nos referimos a este mapeo como codificación de datos, incrustación de datos o carga de datos, y esta es la función del mapa de características. Si bien el mapeo de características es un mecanismo común de ML, este proceso de carga de datos en estados cuánticos no aparece en el machine learning clásico, ya que solo funciona en el mundo clásico.</p>
<p>Una vez cargados los datos, debemos aplicar inmediatamente un circuito cuántico parametrizado. Este circuito es un análogo directo a las capas en las redes neuronales clásicas. Tiene un conjunto de parámetros o pesos ajustables. Los pesos se optimizan de manera que minimicen una función objetivo. Esta función objetivo caracteriza la distancia entre las predicciones y los datos etiquetados conocidos. Un circuito cuántico parametrizado también se denomina estado de prueba parametrizado, forma variacional o ansatz. Quizás, este último es el término más utilizado.</p>
<p>Para obtener más información, dirigimos al lector al <a class="reference external" href="https://learn.qiskit.org/course/machine-learning">Curso de Machine Learning Cuántico</a>.</p>
<p>Nuestra elección de mapa de características será <code class="docutils literal notranslate"><span class="pre">ZZFeatureMap</span></code>. El <code class="docutils literal notranslate"><span class="pre">ZZFeatureMap</span></code> es uno de los mapas de características estándar en la biblioteca de circuitos de Qiskit. Pasamos <code class="docutils literal notranslate"><span class="pre">num_features</span></code> como <code class="docutils literal notranslate"><span class="pre">feature_dimension</span></code>, lo que significa que el mapa de características tendrá <code class="docutils literal notranslate"><span class="pre">num_features</span></code> o <code class="docutils literal notranslate"><span class="pre">4</span></code> qubits.</p>
<p>Descomponemos el mapa de características en sus compuertas constituyentes para darle al lector una idea de cómo pueden verse los mapas de características.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.circuit.library</span> <span class="kn">import</span> <span class="n">ZZFeatureMap</span>

<span class="n">num_features</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">feature_map</span> <span class="o">=</span> <span class="n">ZZFeatureMap</span><span class="p">(</span><span class="n">feature_dimension</span><span class="o">=</span><span class="n">num_features</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">feature_map</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s2">&quot;mpl&quot;</span><span class="p">,</span> <span class="n">fold</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorials_02a_training_a_quantum_model_on_a_real_dataset_17_0.png" src="../_images/tutorials_02a_training_a_quantum_model_on_a_real_dataset_17_0.png" />
</div>
</div>
<p>Si observas detenidamente el diagrama del mapa de características, notarás los parámetros <code class="docutils literal notranslate"><span class="pre">x[0],</span> <span class="pre">...,</span> <span class="pre">x[3]</span></code>. Estos son marcadores de posición para nuestras funciones.</p>
<p>Ahora creamos y mostramos nuestro ansatz. Presta atención a la estructura repetitiva del circuito ansatz. Definimos el número de estas repeticiones usando el parámetro <code class="docutils literal notranslate"><span class="pre">reps</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.circuit.library</span> <span class="kn">import</span> <span class="n">RealAmplitudes</span>

<span class="n">ansatz</span> <span class="o">=</span> <span class="n">RealAmplitudes</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="n">num_features</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">ansatz</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s2">&quot;mpl&quot;</span><span class="p">,</span> <span class="n">fold</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorials_02a_training_a_quantum_model_on_a_real_dataset_19_0.png" src="../_images/tutorials_02a_training_a_quantum_model_on_a_real_dataset_19_0.png" />
</div>
</div>
<p>Este circuito tiene 16 parámetros llamados <code class="docutils literal notranslate"><span class="pre">θ[0],</span> <span class="pre">...,</span> <span class="pre">θ[15]</span></code>. Estos son los pesos entrenables del clasificador.</p>
<p>Luego elegimos un algoritmo de optimización para usar en el proceso de entrenamiento. Este paso es similar a lo que puedes encontrar en los frameworks clásicos de deep learning. Para acelerar el proceso de entrenamiento, elegimos un optimizador sin gradiente. Puedes explorar otros optimizadores disponibles en Qiskit.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit_algorithms.optimizers</span> <span class="kn">import</span> <span class="n">COBYLA</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">COBYLA</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>En el siguiente paso, definimos dónde entrenar nuestro clasificador. Podemos entrenar en un simulador o en una computadora cuántica real. Aquí, usaremos un simulador. Creamos una instancia de la primitiva <code class="docutils literal notranslate"><span class="pre">Sampler</span></code>. Esta es la implementación de referencia en la que está basado el vector de estado. Con los servicios de qiskit runtime, puedes crear un sampler que esté respaldado por una computadora cuántica.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.primitives</span> <span class="kn">import</span> <span class="n">Sampler</span>

<span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>Agregaremos una función de devolución de llamada nombrada <code class="docutils literal notranslate"><span class="pre">callback_graph</span></code>. <code class="docutils literal notranslate"><span class="pre">VQC</span></code> llamará a esta función para cada evaluación de la función objetivo con dos parámetros: los pesos actuales y el valor de la función objetivo en esos pesos. Nuestra devolución de llamada agregará el valor de la función objetivo a una matriz para que podamos graficar la iteración frente al valor de la función objetivo. La devolución de llamada actualizará la gráfica en cada iteración. Ten en cuenta que puedes hacer lo que quieras dentro de una función de devolución de llamada, siempre que tenga la firma de dos parámetros que mencionamos anteriormente.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">clear_output</span>

<span class="n">objective_func_vals</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.figsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">callback_graph</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">obj_func_eval</span><span class="p">):</span>
    <span class="n">clear_output</span><span class="p">(</span><span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">objective_func_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_func_eval</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Objective function value against iteration&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Iteration&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Objective function value&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">objective_func_vals</span><span class="p">)),</span> <span class="n">objective_func_vals</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>Ahora estamos listos para construir el clasificador y ajustarlo.</p>
<p><code class="docutils literal notranslate"><span class="pre">VQC</span></code> significa «clasificador cuántico variacional» («variational quantum classifier.»). Toma un mapa de características y un ansatz y construye una red neuronal cuántica automáticamente. En el caso más simple, basta con pasar el número de qubits y una quantum instance para construir un clasificador válido. Puedes omitir el parámetro <code class="docutils literal notranslate"><span class="pre">sampler</span></code>, en este caso se creará una instancia de <code class="docutils literal notranslate"><span class="pre">Sampler</span></code> de la forma en que la creamos anteriormente. Lo creamos manualmente solo con fines ilustrativos.</p>
<p>El entrenamiento puede tomar algún tiempo. Por favor sé paciente.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">qiskit_machine_learning.algorithms.classifiers</span> <span class="kn">import</span> <span class="n">VQC</span>

<span class="n">vqc</span> <span class="o">=</span> <span class="n">VQC</span><span class="p">(</span>
    <span class="n">sampler</span><span class="o">=</span><span class="n">sampler</span><span class="p">,</span>
    <span class="n">feature_map</span><span class="o">=</span><span class="n">feature_map</span><span class="p">,</span>
    <span class="n">ansatz</span><span class="o">=</span><span class="n">ansatz</span><span class="p">,</span>
    <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
    <span class="n">callback</span><span class="o">=</span><span class="n">callback_graph</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># clear objective value history</span>
<span class="n">objective_func_vals</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">vqc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_features</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>
<span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Training time: </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">elapsed</span><span class="p">)</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorials_02a_training_a_quantum_model_on_a_real_dataset_27_0.png" src="../_images/tutorials_02a_training_a_quantum_model_on_a_real_dataset_27_0.png" />
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Training time: 303 seconds
</pre></div></div>
</div>
<p>Veamos cómo se comporta el modelo cuántico en el conjunto de datos en la vida real.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_score_q4</span> <span class="o">=</span> <span class="n">vqc</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">train_features</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>
<span class="n">test_score_q4</span> <span class="o">=</span> <span class="n">vqc</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">test_features</span><span class="p">,</span> <span class="n">test_labels</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Quantum VQC on the training dataset: </span><span class="si">{</span><span class="n">train_score_q4</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Quantum VQC on the test dataset:     </span><span class="si">{</span><span class="n">test_score_q4</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Quantum VQC on the training dataset: 0.85
Quantum VQC on the test dataset:     0.87
</pre></div></div>
</div>
<p>Como podemos ver, las puntuaciones son altas y el modelo se puede usar para predecir etiquetas en datos no vistos.</p>
<p>Ahora veamos qué podemos ajustar para obtener modelos aún mejores.</p>
<ul class="simple">
<li><p>Los componentes clave son el mapa de características y el ansatz. Puedes ajustar los parámetros. En nuestro caso, puedes cambiar el parámetro <code class="docutils literal notranslate"><span class="pre">reps</span></code> que especifica cuántas repeticiones de un patrón de compuertas agregamos al circuito. Los valores más grandes conducen a más operaciones de entrelazamiento y más parámetros. Por lo tanto, el modelo puede ser más flexible, pero la mayor cantidad de parámetros también agrega complejidad, y el entrenamiento de dicho modelo suele llevar más tiempo. Además, podemos terminar sobreajustando el modelo. Puedes probar los otros mapas de características y ansatzes disponibles en la <a class="reference external" href="https://qiskit.org/documentation/apidoc/circuit_library.html#n-local-circuits">biblioteca de circuitos de Qiskit</a>, o puedes crear circuitos personalizados.</p></li>
<li><p>Puedes probar otros optimizadores. Qiskit contiene un montón de ellos. Algunos de ellos están libres de gradientes, otros no. Si eliges un optimizador basado en gradiente, por ejemplo, <code class="docutils literal notranslate"><span class="pre">L_BFGS_B</span></code>, espera que aumente el tiempo de entrenamiento. Además de la función objetivo, estos optimizadores deben evaluar el gradiente con respecto a los parámetros de entrenamiento, lo que conduce a un mayor número de ejecuciones del circuito por iteración.</p></li>
<li><p>Otra opción es muestrear aleatoriamente (o de manera determinista) el <code class="docutils literal notranslate"><span class="pre">initial_point</span></code> y ajustar el modelo varias veces.</p></li>
</ul>
<p>Pero, ¿qué sucede si un conjunto de datos contiene más características de las que puede manejar una computadora cuántica moderna? Recuerda, en este ejemplo, teníamos la misma cantidad de qubits que la cantidad de características en el conjunto de datos, pero es posible que este no sea siempre el caso.</p>
</section>
<section id="4.-Reducción-del-Número-de-Características">
<h2>4. Reducción del Número de Características<a class="headerlink" href="#4.-Reducción-del-Número-de-Características" title="Enlace permanente a este encabezado">#</a></h2>
<p>En esta sección, reducimos la cantidad de características en nuestro conjunto de datos y volvemos a entrenar nuestros modelos. Avanzaremos más rápido esta vez, ya que los pasos son los mismos, excepto el primero, donde aplicamos una transformación PCA.</p>
<p>Transformamos nuestras cuatro características en solo dos características. Esta reducción de dimensionalidad es solo para fines educativos. Como viste en la sección anterior, podemos entrenar un modelo cuántico usando las cuatro características del conjunto de datos.</p>
<p>Ahora, podemos graficar fácilmente estas dos características en una sola figura.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>

<span class="n">features</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.figsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">sns</span><span class="o">.</span><span class="n">scatterplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">features</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">features</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">hue</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="s2">&quot;tab10&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;AxesSubplot:&gt;
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorials_02a_training_a_quantum_model_on_a_real_dataset_31_1.png" src="../_images/tutorials_02a_training_a_quantum_model_on_a_real_dataset_31_1.png" />
</div>
</div>
<p>Como de costumbre, primero dividimos el conjunto de datos y luego ajustamos un modelo clásico.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_features</span><span class="p">,</span> <span class="n">test_features</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">,</span> <span class="n">test_labels</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
    <span class="n">features</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">algorithm_globals</span><span class="o">.</span><span class="n">random_seed</span>
<span class="p">)</span>

<span class="n">svc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_features</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>

<span class="n">train_score_c2</span> <span class="o">=</span> <span class="n">svc</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">train_features</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>
<span class="n">test_score_c2</span> <span class="o">=</span> <span class="n">svc</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">test_features</span><span class="p">,</span> <span class="n">test_labels</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Classical SVC on the training dataset: </span><span class="si">{</span><span class="n">train_score_c2</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Classical SVC on the test dataset:     </span><span class="si">{</span><span class="n">test_score_c2</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Classical SVC on the training dataset: 0.97
Classical SVC on the test dataset:     0.90
</pre></div></div>
</div>
<p>Los resultados siguen siendo buenos pero ligeramente peores en comparación con la versión inicial. Veamos cómo los trata un modelo cuántico. Como ahora tenemos dos qubits, debemos recrear el mapa de características y el ansatz.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_features</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">feature_map</span> <span class="o">=</span> <span class="n">ZZFeatureMap</span><span class="p">(</span><span class="n">feature_dimension</span><span class="o">=</span><span class="n">num_features</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ansatz</span> <span class="o">=</span> <span class="n">RealAmplitudes</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="n">num_features</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>También reducimos la cantidad máxima de iteraciones para las que ejecutamos el proceso de optimización, ya que esperamos que converja más rápido porque ahora tenemos menos qubits.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">COBYLA</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Ahora construimos un clasificador cuántico a partir de los nuevos parámetros y lo entrenamos.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">vqc</span> <span class="o">=</span> <span class="n">VQC</span><span class="p">(</span>
    <span class="n">sampler</span><span class="o">=</span><span class="n">sampler</span><span class="p">,</span>
    <span class="n">feature_map</span><span class="o">=</span><span class="n">feature_map</span><span class="p">,</span>
    <span class="n">ansatz</span><span class="o">=</span><span class="n">ansatz</span><span class="p">,</span>
    <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
    <span class="n">callback</span><span class="o">=</span><span class="n">callback_graph</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># clear objective value history</span>
<span class="n">objective_func_vals</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># make the objective function plot look nicer.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.figsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>


<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">vqc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_features</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>
<span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Training time: </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">elapsed</span><span class="p">)</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorials_02a_training_a_quantum_model_on_a_real_dataset_39_0.png" src="../_images/tutorials_02a_training_a_quantum_model_on_a_real_dataset_39_0.png" />
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Training time: 58 seconds
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_score_q2_ra</span> <span class="o">=</span> <span class="n">vqc</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">train_features</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>
<span class="n">test_score_q2_ra</span> <span class="o">=</span> <span class="n">vqc</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">test_features</span><span class="p">,</span> <span class="n">test_labels</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Quantum VQC on the training dataset using RealAmplitudes: </span><span class="si">{</span><span class="n">train_score_q2_ra</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Quantum VQC on the test dataset using RealAmplitudes:     </span><span class="si">{</span><span class="n">test_score_q2_ra</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Quantum VQC on the training dataset using RealAmplitudes: 0.58
Quantum VQC on the test dataset using RealAmplitudes:     0.63
</pre></div></div>
</div>
<p>Bueno, las puntuaciones son más altas que en un lanzamiento de moneda balanceada, pero podrían ser mejores. La función objetivo es casi plana hacia el final, lo que significa que aumentar el número de iteraciones no ayudará y el rendimiento del modelo seguirá siendo el mismo. Veamos qué podemos hacer con otro ansatz.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.circuit.library</span> <span class="kn">import</span> <span class="n">EfficientSU2</span>

<span class="n">ansatz</span> <span class="o">=</span> <span class="n">EfficientSU2</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">=</span><span class="n">num_features</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">COBYLA</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>

<span class="n">vqc</span> <span class="o">=</span> <span class="n">VQC</span><span class="p">(</span>
    <span class="n">sampler</span><span class="o">=</span><span class="n">sampler</span><span class="p">,</span>
    <span class="n">feature_map</span><span class="o">=</span><span class="n">feature_map</span><span class="p">,</span>
    <span class="n">ansatz</span><span class="o">=</span><span class="n">ansatz</span><span class="p">,</span>
    <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
    <span class="n">callback</span><span class="o">=</span><span class="n">callback_graph</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># clear objective value history</span>
<span class="n">objective_func_vals</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">vqc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_features</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>
<span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Training time: </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">elapsed</span><span class="p">)</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorials_02a_training_a_quantum_model_on_a_real_dataset_42_0.png" src="../_images/tutorials_02a_training_a_quantum_model_on_a_real_dataset_42_0.png" />
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Training time: 74 seconds
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_score_q2_eff</span> <span class="o">=</span> <span class="n">vqc</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">train_features</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>
<span class="n">test_score_q2_eff</span> <span class="o">=</span> <span class="n">vqc</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">test_features</span><span class="p">,</span> <span class="n">test_labels</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Quantum VQC on the training dataset using EfficientSU2: </span><span class="si">{</span><span class="n">train_score_q2_eff</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Quantum VQC on the test dataset using EfficientSU2:     </span><span class="si">{</span><span class="n">test_score_q2_eff</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Quantum VQC on the training dataset using EfficientSU2: 0.78
Quantum VQC on the test dataset using EfficientSU2:     0.80
</pre></div></div>
</div>
<p>Las puntuaciones son mejores que en la configuración anterior. Quizás si hubiéramos usado más iteraciones, podríamos hacerlo aún mejor.</p>
</section>
<section id="5.-Conclusión">
<h2>5. Conclusión<a class="headerlink" href="#5.-Conclusión" title="Enlace permanente a este encabezado">#</a></h2>
<p>En este tutorial, hemos construido dos modelos de machine learning clásicos y tres cuánticos. Imprimamos una tabla general con nuestros resultados.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[24]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model                           | Test Score | Train Score&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SVC, 4 features                 | </span><span class="si">{</span><span class="n">train_score_c4</span><span class="si">:</span><span class="s2">10.2f</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="n">test_score_c4</span><span class="si">:</span><span class="s2">10.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;VQC, 4 features, RealAmplitudes | </span><span class="si">{</span><span class="n">train_score_q4</span><span class="si">:</span><span class="s2">10.2f</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="n">test_score_q4</span><span class="si">:</span><span class="s2">10.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;----------------------------------------------------------&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SVC, 2 features                 | </span><span class="si">{</span><span class="n">train_score_c2</span><span class="si">:</span><span class="s2">10.2f</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="n">test_score_c2</span><span class="si">:</span><span class="s2">10.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;VQC, 2 features, RealAmplitudes | </span><span class="si">{</span><span class="n">train_score_q2_ra</span><span class="si">:</span><span class="s2">10.2f</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="n">test_score_q2_ra</span><span class="si">:</span><span class="s2">10.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;VQC, 2 features, EfficientSU2   | </span><span class="si">{</span><span class="n">train_score_q2_eff</span><span class="si">:</span><span class="s2">10.2f</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="n">test_score_q2_eff</span><span class="si">:</span><span class="s2">10.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Model                           | Test Score | Train Score
SVC, 4 features                 |       0.99 |       0.97
VQC, 4 features, RealAmplitudes |       0.85 |       0.87
----------------------------------------------------------
SVC, 2 features                 |       0.97 |       0.90
VQC, 2 features, RealAmplitudes |       0.58 |       0.63
VQC, 2 features, EfficientSU2   |       0.78 |       0.80
</pre></div></div>
</div>
<p>Como era de esperar, los modelos clásicos funcionan mejor que sus homólogos cuánticos, pero el ML clásico ha recorrido un largo camino y el ML cuántico aún tiene que alcanzar ese nivel de madurez. Como podemos ver, logramos los mejores resultados utilizando una máquina de vectores de soporte clásica. Pero el modelo cuántico entrenado con cuatro características también fue bastante bueno. Cuando redujimos la cantidad de características, el rendimiento de todos los modelos disminuyó como se esperaba. Por lo tanto, si los recursos permiten entrenar un modelo en un conjunto de datos con todas las características sin ninguna reducción, debes entrenar dicho modelo. De lo contrario, es posible que te comprometas entre el tamaño del conjunto de datos, el tiempo de entrenamiento y la puntuación.</p>
<p>Otra observación es que incluso un simple cambio de ansatz puede conducir a mejores resultados. El modelo de dos características con el ansatz <code class="docutils literal notranslate"><span class="pre">EfficientSU2</span></code> funciona mejor que el de <code class="docutils literal notranslate"><span class="pre">RealAmplitudes</span></code>. Eso significa que la elección de los hiperparámetros desempeña el mismo papel fundamental en el ML cuántico que en el ML clásico, y la búsqueda de hiperparámetros óptimos puede llevar mucho tiempo. Puedes aplicar las mismas técnicas que usamos en el ML clásico, como la aleatoriedad/cuadrícula o enfoques más sofisticados.</p>
<p>Esperamos que este breve tutorial te ayude a dar el salto del ML clásico al ML cuántico.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[25]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">qiskit.tools.jupyter</span>

<span class="o">%</span><span class="k">qiskit_version_table</span>
<span class="o">%</span><span class="k">qiskit_copyright</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<h3>Version Information</h3><table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td><code>qiskit-terra</code></td><td>0.22.0</td></tr><tr><td><code>qiskit-aer</code></td><td>0.11.0</td></tr><tr><td><code>qiskit-ignis</code></td><td>0.7.0</td></tr><tr><td><code>qiskit</code></td><td>0.33.0</td></tr><tr><td><code>qiskit-machine-learning</code></td><td>0.5.0</td></tr><tr><th>System information</th></tr><tr><td>Python version</td><td>3.7.9</td></tr><tr><td>Python compiler</td><td>MSC v.1916 64 bit (AMD64)</td></tr><tr><td>Python build</td><td>default, Aug 31 2020 17:10:11</td></tr><tr><td>OS</td><td>Windows</td></tr><tr><td>CPUs</td><td>4</td></tr><tr><td>Memory (Gb)</td><td>31.837730407714844</td></tr><tr><td colspan='2'>Fri Oct 14 14:33:06 2022 GMT Daylight Time</td></tr></table></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<div style='width: 100%; background-color:#d5d9e0;padding-left: 10px; padding-bottom: 10px; padding-right: 10px; padding-top: 5px'><h3>This code is a part of Qiskit</h3><p>&copy; Copyright IBM 2017, 2022.</p><p>This code is licensed under the Apache License, Version 2.0. You may<br>obtain a copy of this license in the LICENSE.txt file in the root directory<br> of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.<p>Any modifications or derivative works of this code must retain this<br>copyright notice, and modified files need to carry a notice indicating<br>that they have been altered from the originals.</p></div></div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
  <script>
    function userFeedbackClicked(ctaType) {
      document.getElementById('qiskit-analytics-thank-you').style.visibility = 'visible';
      window.trackCta(`Helpful - ${ctaType}`);
    }
  </script>
    <div class="qiskit-analytics-container">
      <div>Was this page helpful?</div>
      <a onclick="userFeedbackClicked('yes')">Yes</a>
      <a onclick="userFeedbackClicked('no')">No</a>
      <div id="qiskit-analytics-thank-you">Thank you!</div>
    </div>
<div class="related-pages">
          <a class="next-page" href="03_quantum_kernel.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Machine Learning con Kernel Cuántico</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="02_neural_network_classifier_and_regressor.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Redes Neuronales de Clasificación y Regresión</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2018, 2024, Qiskit Machine Learning Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Entrenamiento de un Modelo Cuántico en un Conjunto de Datos Real</a><ul>
<li><a class="reference internal" href="#1.-Análisis-de-Datos-Exploratorios">1. Análisis de Datos Exploratorios</a></li>
<li><a class="reference internal" href="#2.-Entrenamiento-de-un-Modelo-Clásico-de-Machine-Learning">2. Entrenamiento de un Modelo Clásico de Machine Learning</a></li>
<li><a class="reference internal" href="#3.-Entrenamiento-de-un-Modelo-de-Machine-Learning-Cuántico">3. Entrenamiento de un Modelo de Machine Learning Cuántico</a></li>
<li><a class="reference internal" href="#4.-Reducción-del-Número-de-Características">4. Reducción del Número de Características</a></li>
<li><a class="reference internal" href="#5.-Conclusión">5. Conclusión</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/jquery.js?v=5d32c60e"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=99a64b57"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../_static/scripts/qiskit-sphinx-theme.js?v=4d77b8ca"></script>
    <script src="../_static/design-tabs.js?v=36754332"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>